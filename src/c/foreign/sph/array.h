
#ifndef sph_array_h
#define sph_array_h

#include <sph/status.h>

#define sph_array_status_id_memory 1
#define sph_array_status_group ((uint8_t*)("sph"))
#define sph_array_memory_error status_set_goto(sph_array_status_group, sph_array_status_id_memory)
#define sph_array_growth_factor 2
#define sph_array_declare_type_custom(name, element_type, sph_array_alloc, sph_array_realloc, sph_array_free) \
  typedef struct { \
    element_type* data; \
    size_t size; \
    size_t used; \
  } name##_t; \
  status_t name##_new(size_t size, name##_t* a) { \
    status_declare; \
    element_type* data = sph_array_alloc((size * sizeof(element_type))); \
    if (!data) { \
      sph_array_memory_error; \
    }; \
    a->data = data; \
    a->size = size; \
    a->used = 0; \
  exit: \
    status_return; \
  } \
  status_t name##_resize(name##_t* a, size_t new_size) { \
    status_declare; \
    element_type* data = sph_array_realloc((a->data), (new_size * sizeof(element_type))); \
    if (!data) { \
      sph_array_memory_error; \
    }; \
    a->data = data; \
    a->size = new_size; \
    a->used = ((new_size < a->used) ? new_size : a->used); \
  exit: \
    status_return; \
  } \
  void name##_free(name##_t* a) { sph_array_free((a->data)); } \
  status_t name##_ensure(name##_t* a, size_t needed) { \
    status_declare; \
    return ((a->data ? (((a->size - a->used) < needed) ? name##_resize(a, (sph_array_growth_factor * a->size)) : status) : name##_new(needed, a))); \
  }
#define sph_array_declare_type(name, element_type) sph_array_declare_type_custom(name, element_type, malloc, realloc, free)
#define sph_array_declare(a, type) type a = { 0, 0, 0 }
#define sph_array_add(a, value) \
  (a.data)[a.used] = value; \
  a.used += 1
#define sph_array_set_null(a) \
  a.used = 0; \
  a.size = 0; \
  a.data = 0
#define sph_array_get(a, index) (a.data)[index]
#define sph_array_get_pointer(a, index) (a.data + index)
#define sph_array_clear(a) a.used = 0
#define sph_array_remove(a) a.used -= 1
#define sph_array_unused_size(a) (a.size - a.used)
#define sph_array_full(a) (a.used == a.size)
#define sph_array_not_full(a) (a.used < a.size)
#define sph_array_take(a, data, size, used) \
  a->data = data; \
  a->size = size; \
  a->used = used
#define sph_array_last(a) (a.data)[(a.used - 1)]
#define sph_array_first_unused(a) (a.data)[a.used]
#define sph_array_declare_stack(name, array_size, type_t, value_t) \
  value_t name##_data[array_size]; \
  type_t name; \
  name.data = name##_data; \
  name.size = array_size; \
  name.used = 0
#endif
