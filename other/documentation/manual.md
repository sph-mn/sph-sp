# sph-sp manual
*draft*

* sph-sp compiles to a shared object library and includes a header file with declarations for programming with c
* error handling uses [sph-sc-lib status](https://github.com/sph-mn/sph-sc-lib#status)

# fundamental data types
## sp_sample_t
* quasi continuous values in floating point format
* c data type for example double or float
* not necessarily equal with =, can be approximately equal in a range
* can store integers without rounding errors, but decimal values are subject to errors from rounding to the size of the type
* summation, especially of values with large differences, introduces accumulating rounding errors that may in practice be in a negligible range

## sp_time_t
* discrete values as integers
* c data type for example uint32_t or uint64_t
* can store only positive values
* subtracting to lower than zero subtracts from the largest possible value
* addition beyond the maximum value adds to zero

## block
samples for multiple channels in one object

prefix: sp_block

~~~
sp_block_t
  sp_channel_count_t channels
  sp_time_t size
  sp_sample_t samples[sp_channel_limit]
~~~

important functions
~~~
status_t sp_block_new(sp_channel_count_t channel_count, sp_time_t sample_count, sp_block_t* out_block);
void sp_block_zero(sp_block_t a);
status_t sp_block_to_file(sp_block_t block, uint8_t* path, sp_time_t rate);
void sp_block_free(sp_block_t a);
sp_block_t sp_block_with_offset(sp_block_t a, sp_time_t offset);
~~~

# sample processors
* sp_wave
* sp_noise
* sp_cheap_noise

# interpolated paths
specify two dimensional points and interpolation methods and get arrays for sampled paths between them.

* inspired by svg paths
* use cases: envelopes and other modulation paths
* prefix: sp_path

# sequencing
sp_seq called with a sorted array of event objects will write event output for a time span to a block

## event
* event.f and event.free are custom functions
* event.state is for custom data passed to the functions
* events compose
* standard event functions support being called with less channels than there are in the output block

## group
* can contain multiple events
* can contain multiple memory addresses that will be freed with the group event

~~~
status_t sp_group_new(sp_time_t start, sp_group_size_t event_size, sp_group_size_t memory_size, sp_event_t* out);
sp_group_memory_add(a, pointer);
sp_group_add(a, event);
~~~

## wave-event
generate sines or other waves

## noise-event
generate noise with a windowed-sinc filter

## cheap-noise-event
* generate noise less processing intensive with a state-variable filter
* cutoff not as sharp as noise-event

## map-event
post process event output

~~~
void scale(sp_time_t start, sp_time_t end, sp_block_t in, sp_block_t out, sp_event_t* event, void* state) {
  sp_time_t i;
  sp_channel_count_t ci;
  sp_sample_t v;
  for (ci = 0; (ci < out.channels); ci += 1) {
    for (i = 0; (i < out.size); i += 1) {
      v = (0 - (((2 * d6_volume) / M_PI) * (in.samples)[ci][i]));
      v = sp_max((-1 * d6_volume), v);
      v = sp_min(d6_volume, v);
      (out.samples)[ci][i] = v;
    };
  };
}

sp_map_event(group, scale, 0, &group);
~~~

## bar-event
create an event group with events at specified offsets and generated by a specified function and custom per-event parameters

# rendering
targets: file, plot
options: parallel

# internals
* memory is sometimes locally registered with [sph-sc-lib memreg](https://github.com/sph-mn/sph-sc-lib#memreg)
